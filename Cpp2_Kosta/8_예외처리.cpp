#include<iostream>

using namespace std;

void Divide(int a, int b) {
	if (!b)
		throw b;

	cout << "나누기 결과 : " << a / b << endl;
}

void main() {
	int a = 0;
	int b = 0;

	cin >> a;
	cin >> b;
	/*
	if (b) {
		cout << "나누기 결과 : " << a / b << endl;
	}
	else {
		cout << "나누기 안됨(0이 입력됨)" << endl;
	}
	*/

	try
	{
		if (a < 0) {
			throw "나누어질 수가 음수입니다.";
		}
		Divide(a, b);
	}
	//catch (const std::exception&)
	catch (int exp)
	{
		cout << "나누기 안됨(0이 입력됨)" << endl;
	}
	catch (const char* msg) {
		cout << msg << endl;
	}



	//b ? cout << "나누기 결과" << a / b << endl : cout << "나누기 안됨" << endl;

	// nullish 병합 연산자 ??
}

// stl이 상위 언어에서 어떻게 이어지는지? 특징 파악?
// Standard Template Library
// 템플릿의 철학은 누구나 공통적으로 사용하기 위한 일반화 프로그래밍(Generic Programming)
// 무분별한 여러 형태의 코드를 지양하고 표준화된 코드를 지향한다.

// 컨테이너 => 배열하고 비슷하고 생각?
// 배열처럼 동일한 요소들로 구성되어야 한다.
// 크게 순차 컨테이너(Sequence Container)와 정렬 연관 컨테이너(Sorted Associactive Container)로 나눌 수 있다.

// 순차 컨테이너 : 동일한 객체가 선형으로 구성된 집합으로 백터, 데크, 리스트 3가지가 있다.
// 백터<vector> : 구성 요소에 임의 접근이 가능하다. 요소 끝에 삽입/삭제는 빠르다. 하지만 중간 삽입/삭제는 요소 개수에 따라 처리 속도가 비례한다.
// 데크<deque> : 백터와 비슷, 양끝에 삽입/삭제 가능, 성능도 백터랑 비슷
// 리스트<list> : 구성 요소에 선형적으로 접근, 요소에 삽입과 삭제가 위치에 상관없이 같은 속도로 처리.

// 정렬 연관 컨테이너
// 셋<set> : 키만 저장할 수 있는데, 키 자체를 데이터로 쓴다. 중복 허용 X
// 맵<map> : 키와 데이터를 같이 관리하는데, 키의 중복은 허용하지 않으므로, 동일한 키가 2개 존재할 수 없으며, 키를 사용하여 원하는 객체를 빠르게 찾아낸다.
// 멀티맵 : 중복키 허용?

// 반복자
// 컨테이너의 요소를 가리키는 객체, 시작부터 끝까지 이동하면서 요소를 읽거나 쓰기 위해 사용한다.
// 컴파일러의 내부 알고리즘은 컴파일러 제작 회사마다 조금씩 다르다.
// 반복자로 성능적 보장?

// 알고리즘
// 정렬, 검색하는 유용한 생각들을 정리해 놓은 함수
// 모두 일반적 => 여러 컨테이너에서 사용할 수 있다.
// 변경 불가 순차 알고리즘, 변경 가능 순차 알고리즘, 정렬 관련 알고리즘, 범용 수치 알고리즘 => 

// STL 특) 일반화 지원한다. 범용적, 공통적으로 사용할 수 있다. 즉 누구나 사용할 수 있도록 하는것
// 컴파일 타임의 매커니즘을 사용 => 실행 시 효율의 저하가 거의 없다. => 런타임이면 저하가 있을 수 있음
// 이식성 확장성 좋음

// 템플릿 기반 => 함수와 클래스가 매번 구체화되어 소스가 비대해짐
// 가독성 구려짐, 뉴비 유입 어려움
// 예외 처리 어려움

// T형으로 가능 vector<T>
// 크기 지정도 되지만 늘릴수있음

// 백터도 앞에 추가 되지만(insert) 매우 느림

// 리스트 : 안에 있는 노드가 논리적인 순서 기억=> 연결리스트